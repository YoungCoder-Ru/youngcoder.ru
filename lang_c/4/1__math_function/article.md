# Стандартные математические функции в языке Си

Математические вычисления не ограничиваются лишь арифметическими действиями. Кроме них, можно ещё встретить корни, модули, логарифмы, тригонометрические функции и пр. Научимся же использовать подобные функции в своих программах.

Для использования математических функций нужно подключить заголовочный файл `math.h`. В этой библиотеке определено много различных функций, но мы пока рассмотрим следующие:

Некоторые математические функции

- `fabs(x)` -- модуль числа x
- `sqrt(x)` -- квадратный корень из числа x
- `sin(x)` -- синус числа x (х в радианах)
- `cos(x)` -- косинус числа x (х в радианах)
- `pow(x, y)` -- вычисление x<sup>y</sup>
- `exp(x)` -- вычисление e<sup>x</sup>
- `log(x)` -- натуральный логарифм числа x
- `log10(x)` -- десятичный логарифм числа x

Два важных момента.

- Все функции возвращают значение типа `double`.
- Параметры функций – вещественные числа `double`, но можно передавать и целые числа. При этом произойдёт `неявное преобразование типа`. Компилятор из целого числа, например 3, сделает вещественное 3.0.

**Примеры:**
Даны длины катетов прямоугольного треугольника. Вычислить длину гипотенузы. Простая задачка на знание теоремы Пифагора.

Листинг 1.

```c
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  int a, b, c2;

  scanf("%d",&a);
  scanf("%d",&b);

  c2 =  a*a + b*b;
  printf("c = %.2f\n", sqrt(c2));

  return 0;
}
```

Вычислить синус угла ввёденного с клавиатуры. Угол вводится в градусах.

Листинг 2.

```c
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  double alpha, sin_a, pi = 3.1415926;

  scanf("%lf",&alpha);
  alpha =  alpha*pi/180;
  sin_a = sin(alpha);
  printf("%.2f\n", sin_a);

  return 0;
}
```

В этой программе есть о чём поговорить. Тригонометрические функции, которые определены в `math.h` работают с радианной мерой угла. Людям же привычнее работать с градусами. Поэтому в данной программе мы предварительно [перевели значение из градусов в радианы](https://stepik.org/lesson/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D0%B2-%D0%A1%D0%B8-40857/step/8). Если этого не сделать, результат получится неправильным. Проверьте это самостоятельно.

## Неявное преобразование типов
При явном преобразовании типа мы в скобках перед значением указывали тип, к которому нужно привести данное значение. В неявном преобразовании этого делать не нужно. Компилятор автоматически подберёт необходимый тип.

Неявное преобразование типов осуществляется в следующих случаях:

1. перед передачей аргументов в функцию (как в нашем примере с корнем. Листинг 1.)
2. выполнение арифметических операций с разными типами аргументов
3. перед выполнением присваивания

**Правила неявного преобразования типов**

* если выполняются арифметические операции с разными типами аргументов. Оба аргумента приводятся к большему типу. Порядок типов: `int` < `float` < `double`
* при присваивании. Значение справа от оператора присваивания приводится к типу переменной слева от оператора присваивания. При этом, если больший тип присваивается меньшему, то может произойти потеря точности.

**Примеры:**

- `int+float` будет автоматически преобразовано к `float+float`
- `float/int` будет автоматически преобразовано к `float/float`
- `double*float` будет преобразовано к `double*double`
- `int = double` `double` будет преобразовано к `int` с потерей дробной части
- `float = int` `int` будет преобразовано к `float`
